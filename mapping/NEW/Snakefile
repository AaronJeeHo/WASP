
configfile: "snake_conf.yaml"

import glob


def read_samples():
    """Function to get names and fastq paths from a sample file specified
    in the configuration. Input file is expected to have 3 columns:
    <unique_sample_id> <fastq1_path> <fastq2_path>. Modify this function
    as needed to provide a dictionary of sample_id keys and (fastq1, fastq1) 
    values"""
    f = open(config['sample_file'], "r")
    samp_dict = {}
    for line in f:
        words = line.strip().split()
        samp_dict[words[0]] = (words[1], words[2])

    return samp_dict


rule all:
    input:
        expand(config["output_dir"] + "/{sample}.keep.merge.sort.bam",
               sample=read_samples().keys())

# TODO: rule to make snp input files from VCF or IMPUTE


rule map_bowtie2_paired_end1:
    """map reads using bowtie2"""
    input:
        fastq1=lambda wildcards: read_samples()[wildcards.sample][0],
        fastq2=lambda wildcards: read_samples()[wildcards.sample][1]
    output:
        config["output_dir"] + "/map_step1/{sample}.bam"
    shell:
        "mkdir -p " + config["output_dir"] + "/map_step1 ; "
        "bowtie2 -x {config[bowtie2_index]} -1 {input.fastq1} -2 {input.fastq2} "
        "| samtools view -v -q 10 - > {output}"


rule sort_and_index_bam1:
    """sort and index bam generated by first mapping step"""
    input:
        config["output_dir"] + "/map_step1/{sample}.bam"
    output:
        config["output_dir"] + "/map_step1/{sample}.sort.bam",
        config["output_dir"] + "/map_step1/{sample}.sort.bam.bai"
    shell:
        "samtools sort -o {output[0]} {input}; "
        "samtools index {output[0]}"


rule find_intersecting_snps_paired_end:
    """find intersecting SNPs using WASP script"""
    input:
        bam=config["output_dir"] + "/map_step1/{sample}.sort.bam",
        snps=config["snp_dir"]
    output:
        fastq1=config["output_dir"] + "/map_step1/{sample}.remap.fq1.gz",
        fastq2=config["output_dir"] + "/map_step1/{sample}.remap.fq2.gz",
        keep_bam=config["output_dir"] + "/map_step1/{sample}.keep.bam",
        remap_bam=config["output_dir"] + "/map_step1/{sample}.remap.bam"
    shell:
        "{config[py2]} {config[wasp_dir]/mapping/NEW/find_intersecting_snps.py "
        "    --is_paired_end --is_sorted {input.bam} {input.snps}"


rule map_bowtie2_paired_end2:
    """map reads a second time using bowtie2"""
    input:
        fastq1=config['output_dir'] + "/map_step1/{sample}.remap.fq1.gz",
        fastq2=config['output_dir'] + "/map_step1/{sample}.remap.fq2.gz"
    output:
        config["output_dir"] + "/map_step2/{sample}.bam"
    shell:
        "mkdir -p " + config["output_dir"] + "/map_step2 ; "
        "bowtie2 -x {config[bowtie2_index]} -1 {input.fastq1} -2 {input.fastq2} "
        "| samtools view -v -q 10 - > {output}"
        

rule sort_and_index_bam2:
    """sort and index bam generated by second mapping step"""
    input:
        config["output_dir"] + "/map_step2/{sample}.bam"
    output:
        config["output_dir"] + "/map_step2/{sample}.sort.bam",
        config["output_dir"] + "/map_step2/{sample}.sort.bam.bai"
    shell:
        "samtools sort -o {output[0]} {input}; "
        "samtools index {output[0]}"


rule filter_remapped_reads:
    """filter reads from second mapping step"""
    input:
        to_remap_bam=config['output_dir'] + "/map_step1/{sample}.remap.bam",
        remap_bam=config['output_dir'] + "/map_step2/{sample}.sort.bam",
    output:
        keep_bam=config['output_dir'] + "/map_step2/{sample}.keep.bam"
    shell:
        "{config[py2]} {config[wasp_dir]}/mapping/NEW/filter_remapped_reads.py "
        "  {input.to_remap_bam} {input.remap_bam} {output.keep_bam}"

    
rule merge_bams:
    """merge 'keep' BAM files from mapping steps 1 and 2, then sort and index"""
    input:
        keep1=config['output_dir'] + "/map_step1/{sample}.keep.bam",
        keep2=config['output_dir'] + "/map_step2/{sample}.keep.bam"
    output:
        merge=config['output_dir'] + "/{sample}.keep.merge.bam",
        sort=config['output_dir'] + "/{sample}.keep.merge.sort.bam",
    shell:
        "samtools merge {output.merge} {input.keep1} {input.keep2}; "
        "samtools sort -o {output.sort} {output.merge}; "
        "samtools index {output.sort}"


# TODO: rule to merge duplicate reads

# TODO: rule to write out summary of allele-specific reads
