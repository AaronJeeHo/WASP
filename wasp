#!/usr/bin/env python

# 
# Goals for WASP re-implementation
#   1) No limitation on how far apart PE reads can be
#   2) Take VCF or impute2 formats as input directly
#   3) Simpler code
#   4) Single command for re-mapping rather than 4
#   5) Support for indels
#   6) Output file with that provides read count per-allele at SNPs
#

import sys
import os
import argparse



def parse_options():
    parser = argparse.ArgumentParser()

    # TODO: could add required command argument here, where allowed
    # commands are 'remap', 'rmdup' etc.

    # TODO: Allow user to provide BAM file so that first mapping
    # step can be skipped
    
    parser.add_argument("-m", "--map_command",
                        dest="map_command",
                        required=True, default=None,
                        help="The shell command(s) WASP should use for mapping "
                        "reads. This can be a string providing the command "
                        "or a path to a text file containing the command. "
                        "The strings FASTQ1, FASTQ2 and OUTPUT_BAM are "
                        "variables that WASP replaces with the paths to the "
                        "input fastq files and output BAM file. "
                        "FASTQ2 only needs to be specified if the reads are "
                        "paired end.")
    
    parser.add_argument("-r", "--remap_command",
                        dest="remap_command", default=None,
                        help="Specifies a command that should be used "
                        "for the second round of mapping. By default "
                        "WASP uses the command provided by --map_command for "
                        "both rounds of mapping. A second command is not "
                        "normally required (or recommended) but can be "
                        "needed when the first command modifies the "
                        "reads that are output (e.g. by trimming them)")
    
    parser.add_argument("--fastq1", dest="fastq1",
                        help="Path to the input fastq file",
                        required=True)
    
    parser.add_argument("--fastq2", dest="fastq2",
                        help="Path to the second fastq file (optional: "
                        "only required if paired-end reads are used)",
                        required=False)
    
    parser.add_argument("--output_dir", dest="output_dir",
                        help="Path to output directory where files "
                        "are written",
                        required=True)

    parser.add_argument("snp_files", nargs="+",
                        help="Files containing SNPs that need to be "
                        "checked for mappability issues. The SNP files "
                        "may be in impute2, VCF, or 3 column text file format. "
                        "Each chromosome must have a single file and the "
                        "filename must contain the name of the chromosome. "
                        "The 3 column format is <position> <RefAllele> "
                        "<AltAllele>", required=True)
    
    return parser.parse_args()





class InputOutputPaths(object):
    """This object holds all of the input / 
    output paths that are used by the program"""

    def __init__(self, options):
        self.input_fastq1 = options.fastq1
        self.prefix1 = self.get_prefix(options.fastq1)
            
        if options.fastq2:
            self.input_fastq2 = options.fastq2
            self.prefix2 = self.get_prefix(options.fastq2)            
        else:
            self.input_fastq1 = None
            self.prefix2 = None
            
        self.output_dir = options.output_dir

        if not self.output_dir.endswith("/"):
            self.output_dir = self.output_dir + "/"

        if not os.path.exists(self.output_dir):
            raise IOError("output directory does not exist: %s" %
                          self.output_dir)

        if not os.path.isdir(self.output_dir):
            raise IOError("specified output dir is a directory")
        
        # output from first mapping step
        self.output_bam = self.output_dir + self.prefix1 + ".bam"
        
        # bam files partitioned by whether they need to be remapped or not
        self.to_keep_bam = self.output_dir + self.prefix1 + ".to_keep.bam"
        self.to_remap_bam = self.output_dir + self.prefix1 + ".to_remap.bam"
        
        self.to_remap_fq1 = self.output_dir + self.prefix1 + ".to_remap1.fq"

        if self.prefix2:
            self.to_remap_fq2 = self.output_dir + self.prefix2 + ".to_remap2.fq"
        else:
            self.to_remap_fq2 = None

        # bam files that are remapped
        self.remapped_bam = self.output_dir + self.prefix1 + ".remapped.bam"

        # bam files that should be kept after remapping
        self.remapped_to_keep_bam = self.output_dir + self.prefix1 + \
                                    ".remapped_to_keep.bam"

        # merger of reads that do not overlap SNPs + filtered reads
        # that do overlap SNPs
        self.merged_to_keep_bam = self.output_dir + self.prefix1 + \
                                  ".merged_to_keep.bam"

        
    def get_prefix(self, filename):
        """returns prefix of filename by stripping off
        .gz and .fastq postfixes"""
        tokens = options.fastq1.split(".")
        if tokens[-1] == "gz":
            tokens.pop()
        if tokens[-1] in ["fastq", "FASTQ", "fq", "FQ"]:
            tokens.pop()

        return ".".join(tokens)

        
            
            

            
            
            
        

    



    
    

def get_map_commands(options):
    """Takes map and (optional) remap comamnds specified by command line args,
    and checks if they are files. If they are files, the contents
    of the files are returned, otherwise the specified string is returned.
    If no --remap_command argument is provided, the --map_command argument
    is used in its place.
    """
    
    map1_arg = options.map_command

    if options.remap_command:
        map2_arg = options.remap_command
    else:
        # use same command as map1 step
        map2_arg = options.map_command

    map_args = [map1_arg, map2_arg]
    map_cmds = []

    for i in range(len(map_cmds)):
        map_arg = map_args[i]
        
        if os.path.exists(map_arg):
            if os.path.isfile(map_arg):
                # read command from file
                f = open(options.map_arg)
                map_cmds.append(f.readlines())
                f.close()
            else:
                raise IOError("path for map command is not a "
                              "valid file: %s" % map_arg)
        else:
            # no path exists, assume arg is a shell command
            map_cmds.append(map_arg)

    return map_cmds
    


def get_paths(options, map_command1, map_command2):
    


def main():
    options = parse_options()

    map_command1, map_command2 = get_map_commands(options)
    
    # step 1 - performing mapping using user-provided mapping command
    
    # step 2 - sort BAM file containing mapped reads
    
    # step 3 - find intersecting SNPs and partition BAM file into
    # reads that overlap SNPs and reads that do not

    # step 4 - remap reads that overlap SNPs

    # step 5 - sort BAM file containing remapped reads

    # step 6 - filter remapped reads that do not map to same location

    # step 7 - merge filtered reads with reads that did not overlap SNPs

    # step 8 (optional) - remove duplicate reads
    
                        


if __name__ == '__main__':
    main()
