#!/usr/bin/env python

# 
# Goals for WASP re-implementation
#   1) No limitation on how far apart PE reads can be
#   2) Take VCF or impute2 formats as input directly
#   3) Simpler code
#   4) Single command for re-mapping rather than 4
#   5) Support for indels
#   6) Output file with that provides read count per-allele at SNPs
#

import sys
import os
import argparse
import subprocess
import pysam

import filter_remapped_reads


def parse_options():
    parser = argparse.ArgumentParser()

    # TODO: could add required command argument here, where allowed
    # commands are 'remap', 'rmdup' etc.

    # TODO: Allow user to provide BAM file so that first mapping
    # step can be skipped
    
    parser.add_argument("-m", "--map_command",
                        dest="map_command",
                        required=True, default=None,
                        help="The shell command(s) WASP should use for mapping "
                        "reads. This can be a string providing the command "
                        "or a path to a text file containing the command. "
                        "The strings FASTQ1, FASTQ2 and OUTPUT_BAM are "
                        "variables that WASP replaces with the paths to the "
                        "input fastq files and output BAM file. "
                        "FASTQ2 only needs to be specified if the reads are "
                        "paired end.")
    
    parser.add_argument("-r", "--remap_command",
                        dest="remap_command", default=None,
                        help="Specifies a command that should be used "
                        "for the second round of mapping. By default "
                        "WASP uses the command provided by --map_command for "
                        "both rounds of mapping. A second command is not "
                        "normally required (or recommended) but can be "
                        "needed when the first command modifies the "
                        "reads that are output (e.g. by trimming them)")
    
    parser.add_argument("--fastq1", dest="fastq1",
                        help="Path to the input fastq file",
                        required=True)
    
    parser.add_argument("--fastq2", dest="fastq2", default=None,
                        help="Path to the second fastq file (optional: "
                        "only required if paired-end reads are used)",
                        required=False)
    
    parser.add_argument("--output_dir", dest="output_dir",
                        help="Path to directory to write output files "
                        "to",
                        required=True)

    parser.add_argument("snp_files", nargs="+",
                        help="Files containing SNPs that need to be "
                        "checked for mappability issues. The SNP files "
                        "may be in impute2, VCF, or 3 column text file "
                        "format. Each chromosome must have a single file "
                        "and the filename must contain the name of the "
                        "chromosome. The 3 column text file format is: "
                        "<position> <RefAllele> <AltAllele>")
    
    return parser.parse_args()





class InputOutputPaths(object):
    """This object holds all of the input / 
    output paths that are used by the program"""

    def __init__(self, options):
        self.input_fastq1 = options.fastq1
        self.prefix1 = self.get_prefix(options.fastq1)
            
        if options.fastq2:
            self.input_fastq2 = options.fastq2
            self.prefix2 = self.get_prefix(options.fastq2)            
        else:
            self.input_fastq2 = None
            self.prefix2 = None
            
        self.output_dir = options.output_dir

        if not self.output_dir.endswith("/"):
            self.output_dir = self.output_dir + "/"

        if not os.path.exists(self.output_dir):
            raise IOError("output directory does not exist: %s" %
                          self.output_dir)

        if not os.path.isdir(self.output_dir):
            raise IOError("specified output dir is not a directory")
        
        # output from first mapping step
        self.output_bam = self.output_dir + self.prefix1 + ".bam"
        self.sorted_output_bam = self.output_dir + self.prefix1 + ".sort.bam"
        
        # bam files partitioned by whether they need to be remapped or not
        self.to_keep_bam = self.output_dir + self.prefix1 + ".sort.keep.bam"
        self.to_remap_bam = self.output_dir + self.prefix1 + \
                            ".sort.to.remap.bam"
        self.to_remap_num = self.output_dir + self.prefix1 + \
                            ".sort.to.remap.num.gz"
        
        self.to_remap_fastq1 = self.output_dir + self.prefix1 + \
                               ".sort.remap.fq1.gz"

        if self.prefix2:
            self.to_remap_fastq2 = self.output_dir + \
                                   self.prefix1 + ".sort.remap.fq2.gz"
        else:
            self.to_remap_fastq2 = None

        # bam files that are remapped
        self.remapped_bam = self.output_dir + self.prefix1 + ".remapped.bam"

        # bam files that should be kept after remapping
        self.remapped_to_keep_bam = self.output_dir + self.prefix1 + \
                                    ".remapped_to_keep.bam"

        # merger of reads that do not overlap SNPs + filtered reads
        # that do overlap SNPs
        self.merged_to_keep_bam = self.output_dir + self.prefix1 + \
                                  ".merged_to_keep.bam"

        self.sorted_merged_to_keep_bam = self.output_dir + self.prefix1 + \
                                         ".merged_to_keep.sort.bam"


    def get_output_files(self):
        """Returns list of output files"""
        out_files =  [self.output_bam, self.sorted_output_bam,
                      self.to_keep_bam, self.to_remap_bam, self.to_remap_num,
                      self.to_remap_fastq1, self.remapped_bam,
                      self.remapped_to_keep_bam, self.merged_to_keep_bam,
                      self.sorted_merged_to_keep_bam]

        if self.to_remap_fastq2:
            out_files.append(self.to_remap_fastq2)

        return sorted(out_files)

    def get_input_files(self):
        """Returns list of input files"""
        in_files = [self.input_fastq1]
        if self.input_fastq2:
            in_files.append(self.input_fastq2)

        return sorted(in_files)

    
    def get_temp_files(self):
        """Returns list of output files that are temporary"""
        tmp_files = [self.output_bam, self.sorted_output_bam,
                     self.to_keep_bam, self.to_remap_bam, self.to_remap_num,
                     self.to_remap_fastq1, self.remapped_bam,
                     self.remapped_to_keep_bam, self.merged_to_keep_bam]

        if self.to_remap_fastq2:
            tmp_files.append(self.to_remap_fastq2)

        return sorted(tmp_files)

    def remove_output_files(self):
        """removes all output files that currently exist"""
        for out_file in self.get_output_files():
            if os.path.exists(out_file):
                sys.stderr.write("removing output file: %s\n" % out_file)
                os.unlink(out_file)
                


    def write_filenames(self, fh):
        out_files = self.get_output_files()
        input_files = self.get_input_files()
        tmp_files = set(self.get_temp_files())

        fh.write("== Input Files ==\n")
        for in_file in input_files:
            fh.write("  %s\n" % in_file)
        fh.write("== Output Files (* temporary) ==\n")
        for out_file in out_files:
            if out_file in tmp_files:
                fh.write("  %s *\n" % out_file)
            else:
                fh.write("  %s\n" % out_file)
        
        
    def get_prefix(self, path):
        """returns filename prefix by stripping off leading directories as 
        well as .gz and .fastq postfixes"""

        dirs = path.split("/")
        filename = dirs[-1]
        
        tokens = filename.split(".")
        if tokens[-1] == "gz":
            tokens.pop()
        if tokens[-1] in ["fastq", "FASTQ", "fq", "FQ"]:
            tokens.pop()
        
        return ".".join(tokens)

        
            
    

def get_map_commands(options):
    """Takes map and (optional) remap commands specified by command line args,
    and checks if they are files. If they are files, the contents
    of the files are returned, otherwise the specified string is returned.
    If no --remap_command argument is provided, the --map_command argument
    is used in its place.
    """    
    map1_arg = options.map_command

    if options.remap_command:
        map2_arg = options.remap_command
    else:
        # use same command as map1 step
        map2_arg = options.map_command

    map_args = [map1_arg, map2_arg]
    map_cmds = []

    for i in range(len(map_args)):
        map_arg = map_args[i]
        
        if os.path.exists(map_arg):
            if os.path.isfile(map_arg):
                # read command from file
                f = open(options.map_arg)
                map_cmds.append(f.readlines())
                f.close()
            else:
                raise IOError("path for map command is not a "
                              "valid file: %s" % map_arg)
        else:
            # no path exists, assume arg is a shell command
            map_cmds.append(map_arg)

    return map_cmds


def perform_first_mapping(paths, map_command):
    """Performs initial mapping of reads"""
    
    # step 1 - performing mapping using user-provided mapping command
    cmd = map_command.replace("FASTQ1", paths.input_fastq1)

    if "FASTQ2" in map_command:
        if paths.input_fastq2 is None:
            raise ValueError("cannot determine path for FASTQ2 in "
                             "mapping command because --fastq2 option "
                             "not specified")
        cmd = cmd.replace("FASTQ2", paths.input_fastq2)


    cmd = cmd.replace("OUTPUT_BAM", paths.output_bam)

    sys.stderr.write("running command: %s\n" % cmd)
    
    subprocess.check_call(cmd, shell="True")

    # check that output was written to correct place by command
    if not os.path.exists(paths.output_bam):
        raise ValueError("output BAM file '%s' was not created by "
                         "mapping command %s" % (paths.output_bam, cmd))

    return cmd


def remap_reads(paths, map_command):
    """Performs remapping of subset of reads"""
    # step 1 - performing mapping using user-provided mapping command
    cmd = map_command.replace("FASTQ1", paths.to_remap_fastq1)

    if "FASTQ2" in map_command:
        if paths.to_remap_fastq2 is None:
            raise ValueError("cannot determine path for FASTQ2 in "
                             "mapping command because --fastq2 option "
                             "not specified")
        cmd = cmd.replace("FASTQ2", paths.to_remap_fastq2)

    cmd = cmd.replace("OUTPUT_BAM", paths.remapped_bam)

    sys.stderr.write("running command: %s\n" % cmd)
    
    subprocess.check_call(cmd, shell="True")

    # check that output was written to correct place by command
    if not os.path.exists(paths.remapped_bam):
        raise ValueError("output BAM file '%s' was not created by "
                         "mapping command %s" % (paths.remapped_bam, cmd))

    return cmd
    
    


def find_intersecting_snps(options, paths):
    # TODO: Need to change this so that the
    # find_intersecting_snps.py can be called directly as python module.
    # However the script needs to be refactored, so in the meantime
    # shell out call it
    args = []

    # is this paired end?
    if paths.input_fastq2:
        args.append("-p")

    # we already sorted input
    args.append("-s")

    # input BAM file
    args.append(paths.sorted_output_bam)

    # TODO: for now just figure out what snp dir is,
    # eventually allow for list of named files instead?
    tokens = options.snp_files[0].split("/")
    snp_dir = "/".join(tokens[:-1])
    
    # path to SNPs file
    args.append(snp_dir)

    cmd = "python find_intersecting_snps.py " + " ".join(args)
    sys.stderr.write("running command: %s\n" % cmd)
    
    subprocess.check_call(cmd, shell=True)


def filter_reads(options, paths):
    ### TOOD: Need to change this to call filter_remapped_reads.py directly
    ### as python module.

    is_paired_end = True if paths.input_fastq2 else False
    
    filter_remapped_reads.run(paths.to_remap_bam, paths.remapped_bam,
                              paths.remapped_to_keep_bam, paths.to_remap_num,
                              is_paired_end)
    


def merge_bams(options, paths):
    """Merges the remapped and original set of reads that did not 
    need to be remapped"""

    # merge the bam files
    args = ["samtools", "merge", paths.merged_to_keep_bam,
            paths.to_keep_bam, paths.remapped_to_keep_bam]
    cmd = " ".join(args)
    sys.stderr.write("running command: %s\n" % cmd)
    subprocess.check_call(cmd, shell=True)

    # sort the merged bam
    sort_bam(paths.merged_to_keep_bam, paths.output_dir + paths.prefix1 +
             ".merged_to_keep")

    # index the merged bam
    args = ["samtools", "index", paths.sorted_merged_to_keep_bam]
    cmd = " ".join(args)
    sys.stderr.write("running command: %s\n" % cmd)
    subprocess.check_call(cmd, shell=True)
    
    
    
    
def sort_bam(input_bam, output_prefix):
    """Calls samtools sort on input_bam filename and writes to
    output_bam"""

    output_bam = output_prefix + ".sort.bam"
    
    # first try new way of using samtools sort
    failed = False
    cmd = "samtools sort -o " + output_bam + " " + input_bam
    sys.stderr.write("running command: %s\n" % cmd)
    try:
        subprocess.check_call(cmd, shell=True)
    except Exception as e:
        sys.stderr.write("samtools sort command failed:\n%s\n" %
                         str(e))
        failed = True
    if not os.path.exists(output_bam):
        sys.stderr.write("output file %s does not exist\n" % output_bam)
        failed = True
        
    if failed:
        # OLD way of calling samtools (changed in newer versions)
        sys.stderr.write("samtools sort command failed, trying old samtools "
                         "syntax\n")
        
        cmd = "samtools sort " + input_bam + " " + output_prefix
        sys.stderr.write("running command: %s\n" % cmd)

        try:
            subprocess.check_call(cmd, shell=True)
        except Exception as e:
            sys.stderr.write("samtools sort command failed:\n%s\n" %
                             str(e))
            exit(1)
        
        if not os.path.exists(paths.sorted_output_bam):
            raise IOError("Failed to create sorted BAM file '%s'" %
                          paths.sorted_output_bam)
    

    


def main():
    options = parse_options()

    paths = InputOutputPaths(options)

    paths.write_filenames(sys.stderr)
    paths.remove_output_files()

    ## TODO: could check all paths for whether they exist
    ## here to avoid crashing at later step
    
    map_command1, map_command2 = get_map_commands(options)
    
    sys.stderr.write("map_command1: %s\nmap_command2: %s\n" %
                     (map_command1, map_command2))

    # step 1 - perform first mapping: all reads
    sys.stderr.write("== step 1: performing first mapping\n")
    perform_first_mapping(paths, map_command1)
    
    # step 2 - sort BAM file containing mapped reads
    sys.stderr.write("== step 2: sorting BAM file\n")
    sort_bam(paths.output_bam, paths.output_dir + paths.prefix1)
    
    # step 3 - find intersecting SNPs and partition BAM file into
    # reads that overlap SNPs and reads that do not
    sys.stderr.write("== step 3: finding intersecting SNPs\n")
    find_intersecting_snps(options, paths)
    
    # step 4 - remap reads that overlap SNPs
    sys.stderr.write("== step 4: remapping reads that overlap SNPs\n")
    remap_reads(paths, map_command2)
    
    # step 5 - sort BAM file containing remapped reads
    sys.stderr.write("== step 5: sorting remapped reads\n")
    sort_bam(paths.remapped_bam, paths.output_dir + paths.prefix1 + ".remapped")

    # step 6 - filter remapped reads that do not map to same location
    sys.stderr.write("== step 6: filtering remapped reads\n")
    filter_reads(options, paths)

    # step 7 - merge filtered reads with reads that did not overlap SNPs
    sys.stderr.write("== step 7: merging bam files\n")
    merge_bams(options, paths)
    
    # step 8 (optional) - remove duplicate reads
    # TODO: remove duplicate reads
    # TODO: remove temporary files
                        


if __name__ == '__main__':
    main()
